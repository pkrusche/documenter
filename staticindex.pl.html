<html>
<head> <title>staticindex.pl</title>
<script src="js/jquery.js" ></script>
<script src="js/jquery-ui.js" ></script>

<script src="js/highlight.pack.js" ></script>

<script src="js/index.js" ></script>
<script src="js/search.js" ></script>
<script src="js/documenter.js" ></script>

<link rel="stylesheet" type="text/css" href="css/smoothness/jquery-ui-1.8.23.custom.css" />
<link rel="stylesheet" type="text/css" href="css/github.css" />
<link rel="stylesheet" type="text/css" href="css/documenter.css" />

<link rel="alternate" type="application/rss+xml" title="RSS" href="feed.rss">

 <script>
  hljs.tabReplace = '    ';
  hljs.initHighlightingOnLoad();
</script>

</head>

<body>
<div id="toolbar" class="ui-widget-content ui-widget-header ui-corner-all" style="display:none;">
	<center>
		<button id="upbutton">Index</button>
		<button id="indexbutton">Outline</button>&nbsp;
		<span id="search"></span>
		<span id="collapseexpand">
			<button id="collapseall">Collapse Code</button>
			<button id="expandall">Expand Code</button>
		</span>
		<button id="print">Print</button>
	</center>
</div>
<div id="index" class="ui-widget-content ui-corner-all" style="padding: 5px">
	<noscript><a href="static_index.html">Click here to show the complete source index.</a>
	</noscript>
</div>
<div id="content"><a name="line_1" /><a name="line_3" /><h1>Static Index Generator</h1>

<p>Generates a static index from Documenter index JSON</p>
<a name="line_7" /><div class="code"><pre><code class="perl">use strict;

use FindBin qw($Bin);
use lib &quot;$Bin&quot;;

use JSON;
use File::Basename;
use File::Spec qw(catfile);
use XML::RSS;
use Scalar::Util qw(looks_like_number);
use DateTime;
use DateTime::Format::W3CDTF;
use DateTime::Format::Epoch;
use Template;

use Tools::Output;
use Tools::Output::HTML;

use sort &#39;stable&#39;;

if (!defined $ARGV[0]) {
	die &quot;Usage : staticindex.pl &lt;indexfilename&gt; &lt;baseurl=http://localhost:4000/&gt; &lt;flat_type=html&gt;&quot;;
}

my $baseurl = $ARGV[1] || &quot;http://localhost:4000/&quot;;

my $flat_index_type = (lc $ARGV[2]) || &#39;html&#39;;

unless ($baseurl =~ m/\/$/) {
 	$baseurl .= &#39;/&#39;;
}

my $js;
{ local $/ = undef; local *FILE;
	open FILE, &quot;&lt;&quot;, $ARGV[0]; $js = &lt;FILE&gt;; close FILE }

my $f_base = basename($ARGV[0]), &quot;\n&quot;;
my $f_dir  = dirname($ARGV[0]), &quot;\n&quot;;

my $indexdata = from_json($js);

our @linear_index = ();

recurse($indexdata);</code></pre></div><a name="line_54" /><h2>Sorting comparator by index id</h2>

<p>Used for sort, compares two index ids:</p>

<pre><code>1.2.3 &lt; 1.2.4
1.2 &lt; 1.2.4
1.2.3 = 1.2.3
2.0 &gt; 1.9.9
1.11 &gt; 1.1
etc.
</code></pre>
<a name="line_65" /><a name="line_67" /><div class="code"><pre><code class="perl">sub by_idx {
	my $a = shift;
	my $b = shift;
	my $result = 0;
	my @a_s = split /\./, $a-&gt;{linear_index_pos};
	my @b_s = split /\./, $b-&gt;{linear_index_pos};

	my $len = scalar @a_s;
	if (scalar @b_s &lt; $len) {
		$len = scalar @b_s;
	}

	for (my $i = 0; $i &lt; $len; $i++) {
		if ($a_s[$i] ne $b_s[$i]) {
			if (looks_like_number ($a_s[$i]) &amp;&amp;
				looks_like_number ($b_s[$i]) ) {
				return $a_s[$i] &lt;=&gt; $b_s[$i];
			} else {
				return $a_s[$i] cmp $b_s[$i];
			}
		}
	}

	# here, all elements in a_s and b_s were the same
	# check which one of them is shorter
	if (scalar @b_s &lt; scalar @a_s) {
		return -1;
	}
	if (scalar @a_s &lt; scalar @b_s) {
		return 1;
	}

	# equal elements, return;
	return 0;
}</code></pre></div><a name="line_103" /><h2>Recursively process the index tree</h2>

<p><strong>Parameters:</strong> </p>

<blockquote>
<p>$node      : the current node (hash with value and children elements) 
   $path      : the current path (used in recursion) 
   $level     : the current depth 
   $index_pos : the parent&#39;s index position </p>
</blockquote>
<a name="line_111" /><a name="line_113" /><div class="code"><pre><code class="perl">sub recurse {
	my $node = shift;
	my $path = shift || &quot;Index&quot;;
	my $level = shift || 1;
	my $index_pos = shift || &#39;1&#39;;

	my $filename = $node-&gt;{value}-&gt;{link};
	# remove hash tag
	$filename =~ s/\#.*$//;
	$filename =~ s/\.html$//;

	$node-&gt;{value}-&gt;{path}  = $path . &quot;/&quot; . $filename;
	$node-&gt;{value}-&gt;{level} = $level;

	$node-&gt;{value}-&gt;{linear_index_pos} = $index_pos;
	$node-&gt;{value}-&gt;{linear_index_pos} =~ s/[^A-Za-z0-9\.\-\_]/\_/g;

	push @linear_index, $node-&gt;{value}
		if defined ($node-&gt;{value}-&gt;{link}) &amp;&amp; $node-&gt;{value}-&gt;{link} ne &quot;&quot;;

	# default order is lexicographically by path,
	# but we can prioritize items using index_path
	# which is set using markup comments (see PerlParser.pm)
	my @ordered_children = sort {
			my $pa = $a-&gt;{value}-&gt;{index_path} || $a-&gt;{path};
			my $pb = $b-&gt;{value}-&gt;{index_path} || $b-&gt;{path};
			return $pa cmp $pb
		} 	@{$node-&gt;{children}};

	my $sub_index = 1;
	foreach my $c (@ordered_children){
		recurse($c, $node-&gt;{path}, $level + 1,
			$index_pos . &#39;.&#39; . $sub_index);
		$sub_index++;
	}
	# establish index order
	@ordered_children = sort { by_idx($a-&gt;{value}, $b-&gt;{value}) } @ordered_children;
	$node-&gt;{children} = \@ordered_children;
}</code></pre></div><a name="line_153" /><strong>## </strong><span class="monospaced"> write updated index </span><a name="line_154" /><div class="code"><pre><code class="perl">open OUT_INDEX, &quot;&gt;&quot;, $ARGV[0]
	or die &quot;Cannot update index with order information\n&quot;;

print OUT_INDEX to_json($indexdata, {pretty=&gt;1});

close OUT_INDEX;

print &quot;Number of items: &quot;, scalar @linear_index, &quot;\n&quot;;

# create an RSS 2.0 file

my $dt = DateTime-&gt;new( year =&gt; 1970, month =&gt; 1, day =&gt; 1 );

my $parser = DateTime::Format::Epoch-&gt;new(
                      epoch          =&gt; $dt,
                      unit           =&gt; &#39;seconds&#39;,
                      type           =&gt; &#39;int&#39;,    # or &#39;float&#39;, &#39;bigint&#39;
                      skip_leap_seconds =&gt; 1,
                      start_at       =&gt; 0,
                      local_epoch    =&gt; undef,
                  );
my $formatter = DateTime::Format::W3CDTF-&gt;new;

my $rss = XML::RSS-&gt;new (version =&gt; &#39;2.0&#39;);
$rss-&gt;channel(title          =&gt; &#39;Source Index&#39;,
              link           =&gt; $baseurl,
              language       =&gt; &#39;en&#39;,
              description    =&gt; &#39;Source documentation&#39;,
              pubDate        =&gt; $formatter-&gt;format_datetime(DateTime-&gt;now),
              lastBuildDate  =&gt; $formatter-&gt;format_datetime(DateTime-&gt;now),
     );

# index order sorting
sort {by_idx($a, $b)} @linear_index;

my $flat_output;

if ($flat_index_type eq &#39;html&#39;) {
	$flat_output = Tools::Output::HTML-&gt;new;
} else {
	$flat_output = Tools::Output-&gt;new;
}

foreach my $e (@linear_index) {
	my $filename = $e-&gt;{link};
	# remove hash tag
	$filename =~ s/\#.*$//;

	$filename = File::Spec-&gt;catfile($f_dir, $filename);
	my $mod = $formatter-&gt;format_datetime(
		$parser-&gt;parse_datetime( (stat &quot;$filename&quot;)[9] )
		);


	my $vstr = $flat_output-&gt;l($flat_output-&gt;x($e-&gt;{title}), $e-&gt;{link});

	if($e-&gt;{options} =~ m/show\_type/) {
		$vstr = $e-&gt;{type} . &#39; &#39; . $vstr;
	}

	$flat_output-&gt;xt($e-&gt;{linear_index_pos});
	$flat_output-&gt;t(
		&quot;&amp;nbsp;&quot; . $flat_output-&gt;b(
				$vstr
			)
		);

	$flat_output-&gt;t(
		&quot;&amp;nbsp; (&quot; . $flat_output-&gt;i(
				$flat_output-&gt;x($e-&gt;{path})
			)
		. &quot;)&quot;
		);

	$flat_output-&gt;p();

	$rss-&gt;add_item(title =&gt; $e-&gt;{title},
	       # creates a guid field with permaLink=true
	       permaLink  =&gt; $baseurl . $e-&gt;{link},
	       description =&gt;
	       	$e-&gt;{type} . &quot;:&quot; .
	       	$e-&gt;{level} . &quot;:&quot; .
	       	$e-&gt;{linear_index_pos} . &quot;:&quot; .
	       	$e-&gt;{path},
	       dc =&gt; {
              date =&gt; $mod
           },
	);
}

$rss-&gt;save(File::Spec-&gt;catfile($f_dir, &#39;feed.rss&#39;));</code></pre></div><a name="line_246" /><strong>## </strong><span class="monospaced"> make a static index file  process template </span><a name="line_248" /><div class="code"><pre><code class="perl">my $template = Template-&gt;new({
    INCLUDE_PATH =&gt; $Bin,
    ABSOLUTE =&gt; 1,
    EVAL_PERL =&gt; 1,
    OUTPUT =&gt; File::Spec-&gt;catfile($f_dir, &#39;static_index.&#39;.$flat_index_type),
    ENCODING =&gt; &#39;utf8&#39;,
});

my $vars = {
    doc =&gt; {
        TITLE =&gt; &quot;Documentation Index&quot;,
        CONTENT =&gt; $flat_output-&gt;result,
    }
};

my $templatefile = &quot;template.$flat_index_type&quot;;
my $templatedir = File::Spec-&gt;catdir($Bin, &#39;templates&#39;, $flat_index_type);
$templatefile = File::Spec-&gt;catfile($templatedir, $templatefile);

$template-&gt;process (
    $templatefile,
    $vars,
    File::Spec-&gt;catfile($f_dir, &#39;static_index.&#39;.$flat_index_type),
    {binmode=&gt;&#39;utf8&#39;} )
    || die $template-&gt;error();</code></pre></div></div>
<div id="footer" class="ui-widget-content ui-widget-header ui-corner-all">Generated using <a href="https://github.com/pkrusche/documenter">Perl Documenter</a> &copy; 2012 Peter Krusche</div>
</body>
</html>
