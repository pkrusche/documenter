<html>
<head> <title>Tools::PerlParser.pm</title>
<script src="js/jquery.js" ></script>
<script src="js/jquery-ui.js" ></script>

<script src="js/highlight.pack.js" ></script>

<script src="js/index.js" ></script>
<script src="js/search.js" ></script>
<script src="js/documenter.js" ></script>

<link rel="stylesheet" type="text/css" href="css/smoothness/jquery-ui-1.8.23.custom.css" />
<link rel="stylesheet" type="text/css" href="css/github.css" />
<link rel="stylesheet" type="text/css" href="css/documenter.css" />

<link rel="alternate" type="application/rss+xml" title="RSS" href="feed.rss">

 <script>
  hljs.tabReplace = '    ';
  hljs.initHighlightingOnLoad();
</script>

</head>

<body>
<div id="toolbar" class="ui-widget-content ui-widget-header ui-corner-all" style="display:none;">
	<center>
		<button id="upbutton">Index</button>
		<button id="indexbutton">Outline</button>&nbsp;
		<span id="search"></span>
		<span id="collapseexpand">
			<button id="collapseall">Collapse Code</button>
			<button id="expandall">Expand Code</button>
		</span>
		<button id="print">Print</button>
	</center>
</div>
<div id="index" class="ui-widget-content ui-corner-all" style="padding: 5px">
	<noscript><a href="static_index.html">Click here to show the complete source index.</a>
	</noscript>
</div>
<div id="content"><a name="line_1" /><a name="line_4" /><h1>Perl Parser ##0</h1>

<p>This package splits perl code into code, comments and POD code.</p>
<a name="line_6" /><a name="line_8" /><div class="code"><pre><code class="perl">package Tools::PerlParser;

use strict;
use File::Temp qw(tempfile);
use Parse::RecDescent;
use Data::Dumper;

use PPI;
use PPI::Dumper;
use PPI::Find;

use Tools::PerlParser::Declaration;

use Tools::NamedTree;

# state can have three values:
#  code: code that will be pretty-printed
#  pod : pod code
#  comment : multiple lines of comments
#  end : end perl code, everything is pod
our $state = &#39;code&#39;;

# code buffers: current code, and everything
our $current     = &quot;&quot;;
our $everything  = &quot;&quot;;
our $lineno      = 0;
our $last_lineno = 1;

# PPI parser stuff
our $ppidoc = undef;

# table of contents tree
our $countents_tree = undef;

# the declarations subtree
our $declarations_node = undef;

# handler callback functions
our %handlers = ();

our $has_moose = 0;</code></pre></div><a name="line_50" /><h2>Add a handler for a parser state.</h2>

<p>See above for supported states.</p>
<a name="line_53" /><a name="line_55" /><div class="code"><pre><code class="perl">sub setHandler {
	my ( $id, $sub ) = @_;
	our %handlers;
	$handlers{$id} = $sub;
}</code></pre></div><a name="line_61" /><h2>Function to write out parsed source code, comment or POD comments</h2>

<p>Variable $current contains a buffer with the parsed source. This function
prints and formats its contents according to the current state.</p>
<a name="line_64" /><a name="line_66" /><div class="code"><pre><code class="perl">sub flushcurrent {
	our %handlers;
	our ( $state, $current, $lineno, $last_lineno );
	if ( $current eq &quot;&quot; ) {
		return;
	}
	if ( defined( $handlers{$state} ) ) {
		$handlers{$state}-&gt;( $current, $last_lineno );
	}
	$last_lineno = $lineno + 1;
	$current     = &quot;&quot;;
}</code></pre></div><a name="line_79" /><h2>Main parser function</h2>

<p>Crude line by line parser to separate lines with comments only,
code lines and pod lines.</p>

<p><strong>Parameters:</strong> </p>

<blockquote>
<p>$filename : the name of the source file to parse </p>
</blockquote>
<a name="line_86" /><a name="line_88" /><div class="code"><pre><code class="perl">sub parse {
	my $filename = shift;
	our ( $current, $lineno, $state, $everything, $last_lineno, $ppidoc,
		$has_moose );

	$state = &#39;code&#39;;

	# code buffers: current code, and everything
	$current     = &quot;&quot;;
	$everything  = &quot;&quot;;
	$lineno      = 0;
	$last_lineno = 1;
	$ppidoc      = undef;
	$has_moose   = 0;

	# initialize contents tree.
	our $contents_tree = Tools::NamedTree-&gt;new();

	$contents_tree-&gt;value(
		{
			&#39;title&#39;    =&gt; &quot;Outline&quot;,
			&#39;type&#39;     =&gt; &quot;nodisplay&quot;,
			&#39;location&#39; =&gt; 0,
		}
	);

	# headings and pod stuff goes in here.
	my $documentation_node = $contents_tree;
	# -&gt;add_child(
	# 	{
	# 		&#39;title&#39;    =&gt; &quot;Documentation&quot;,
	# 		&#39;type&#39;     =&gt; &quot;h1&quot;,
	# 		&#39;location&#39; =&gt; 0,
	# 	}
	# );

	my @elstack = ();

	my @breaking_points = ();

	open FILE, &quot;&lt;&quot; . $filename
	  or die &quot;Input file $filename not found.&quot;;

	# first pass: get function definitions and such.

	$ppidoc = PPI::Document-&gt;new($filename);

	our $declarations_node = $contents_tree;
	# -&gt;add_child(
	# 	{
	# 		&#39;title&#39;    =&gt; &quot;Declarations&quot;,
	# 		&#39;type&#39;     =&gt; &quot;h1&quot;,
	# 		&#39;location&#39; =&gt; 0,
	# 	}
	# );

	my $globals_node = $declarations_node;
	# -&gt;add_child(
	# 	{
	# 		&#39;title&#39;    =&gt; &quot;Global Variables&quot;,
	# 		&#39;type&#39;     =&gt; &quot;h1&quot;,
	# 		&#39;location&#39; =&gt; 0,
	# 	}
	# );

	my $finder = PPI::Find-&gt;new( \&amp;declarations );

	@elstack = ();
	my @found = $finder-&gt;in($ppidoc);

	my %globals = ();

	foreach my $el (@found) {
		if ( UNIVERSAL::isa( $el, &quot;PPI::Statement::Variable&quot; ) ) {

			# list first occurrences of global variables
			if ( $el-&gt;type() eq &#39;our&#39; ) {
				foreach ( $el-&gt;variables() ) {
					if ( !defined( $globals{$_} ) ) {
						$globals{$_} = $globals_node-&gt;add_child(
							{
								title         =&gt; $_,
								type          =&gt; &quot;global&quot;,
								location      =&gt; $el-&gt;line_number(),
								documentation =&gt; get_documentation($el),
								ppinode       =&gt; $el,
							}
						);
					}
				}
			}
			next;
		}

		# determine where to append this element
		my $append_node = $declarations_node;
		my $keepgoing   = 1;

		my $tt = get_title_and_type($el);

		my $is_package =
		     $tt-&gt;[1] eq &#39;package&#39;
		  || $tt-&gt;[1] eq &#39;class&#39;
		  || $tt-&gt;[1] eq &#39;role&#39;;

		while ( scalar @elstack &gt; 0 &amp;&amp; $keepgoing ) {
			my $top = $elstack[$#elstack];

			my $top_is_package =
			     $top-&gt;{&#39;node&#39;}-&gt;value()-&gt;{&#39;type&#39;} eq &#39;package&#39;
			  || $top-&gt;{&#39;node&#39;}-&gt;value()-&gt;{&#39;type&#39;} eq &#39;class&#39;
			  || $top-&gt;{&#39;node&#39;}-&gt;value()-&gt;{&#39;type&#39;} eq &#39;role&#39;;

			if ( $el-&gt;descendant_of( $top-&gt;{&#39;element&#39;} )
				|| ( !$is_package &amp;&amp; $top_is_package ) )
			{
				$append_node = $top-&gt;{&#39;node&#39;};
				$keepgoing   = 0;
			} else {
				pop @elstack;
			}
		}

		my $el_node = $append_node-&gt;add_child(
			{
				title         =&gt; $tt-&gt;[0],
				type          =&gt; $tt-&gt;[1],
				location      =&gt; $el-&gt;line_number(),
				documentation =&gt; get_documentation($el),
				ppinode       =&gt; $el,
			}
		);

		push @elstack,
		  {
			element =&gt; $el,
			node    =&gt; $el_node,
		  };

		push @breaking_points, $el-&gt;line_number();
	}

	@elstack = ();

	# second pass: get comments, code and pod
	while (&lt;FILE&gt;) {
		my $line = $_;
		$everything .= $line;
		++$lineno;

		while ( scalar @breaking_points &gt; 0
			&amp;&amp; $lineno &gt;= $breaking_points[0] )
		{
			flushcurrent();
			shift @breaking_points;
		}

		$line =~ s/\s*\n$//;

		# go to pod comment state.
		if ( $line =~ m/^=(.*)/ ) {

			# create TOC entry
			if ( $line =~ m/^=head([1-9])\s+(.*)/ ) {
				my $append_node = $documentation_node;
				my $keepgoing   = 1;

				my $level = $1;
				my $text  = $2;

				while ( ( scalar @elstack &gt; 0 ) &amp;&amp; $keepgoing ) {
					my $top = $elstack[$#elstack];
					if ( $level &lt;= $top-&gt;{&#39;level&#39;} ) {
						pop @elstack;
					} else {
						$append_node = $top-&gt;{&#39;node&#39;};
						$keepgoing   = 0;
					}
				}

				my @t = split /\#\#/, $text;

				my $h_node = $append_node-&gt;add_child(
					{
						title    =&gt; $t[0],
						type     =&gt; &quot;h$level&quot;,
						location =&gt; $lineno,
						index_path =&gt; $t[1]
					}
				);

				push(
					@elstack,
					{
						level =&gt; $level,
						node  =&gt; $h_node,
					}
				);
			}

			# change state
			if ( $1 eq &quot;cut&quot; ) {
				if ( $state eq &#39;pod&#39; ) {
					$current .= &quot;\n=cut&quot;;
					flushcurrent();
					$state = &#39;code&#39;;
				} else {
					flushcurrent();
					my $tmp = $state;
					$state = &#39;pod&#39;;
					$current .= $line . &quot;\n&quot;;
					flushcurrent();
					$state = $tmp;
				}
			} else {
				if ( $state ne &#39;pod&#39; ) {
					flushcurrent();
				}
				$state = &#39;pod&#39;;
				$current .= $line . &quot;\n&quot;;
			}

			# end of file
		} elsif ( $line =~ m/^__END__/ ) {
			flushcurrent();
			$state = &#39;end&#39;;

			# single line comment -- starting with at least two #&#39;s
		} elsif ( $line =~ m/^\s*\##(.*)/ ) {
			if ( $state ne &#39;pod&#39; ) {
				if ( $state ne &#39;comment&#39; ) {
					flushcurrent();
				}
				$current .= $1 . &quot;\n&quot;;
				$state = &#39;comment&#39;;
			} else {
				$current .= $line . &quot;\n&quot;;
			}

			# any other lines
		} else {

		# any line that&#39;s not a comment will cause us to leave the comment state
			if ( $state eq &#39;comment&#39; ) {
				flushcurrent( $state, $current );
				$state = &#39;code&#39;;
			}
			$current .= $line . &quot;\n&quot;;
		}
	}
	flushcurrent();
	close FILE;
}</code></pre></div><a name="line_342" /><h2>Get a tree of significant content elements</h2>
<a name="line_344" /><a name="line_346" /><div class="code"><pre><code class="perl">sub get_contents_tree {
	our $contents_tree;
	return $contents_tree;
}</code></pre></div><a name="line_351" /><h2>PPI::Find filter for declarations</h2>

<p><strong>Parameters:</strong> </p>

<blockquote>
<p>$cur : a PPI::Token </p>
</blockquote>

<p><strong>Return:</strong> </p>

<blockquote>
<p>1 if element fits the criteria 
   0 if element does not fit 
   undef if children do not need to be looked at. 
   See also PPI::Find -&gt; &amp;wanted </p>
</blockquote>
<a name="line_362" /><a name="line_364" /><div class="code"><pre><code class="perl">sub declarations {
	my $cur = shift;
	our $has_moose;

	if ( UNIVERSAL::isa( $cur, &quot;PPI::Statement::Include&quot; ) ) {
		my $mod  = $cur-&gt;module();
		my $type = $cur-&gt;type();
		if ( $mod =~ m/^MooseX?/ ) {
			if ( $type eq &#39;no&#39; ) {
				$has_moose = 0;
			} else {
				$has_moose = 1;
			}
		}
	}

	return Tools::PerlParser::Declaration::is_declaration( $cur, $has_moose );
}</code></pre></div><a name="line_383" /><h2>Get all method, class, package and variable declaration nodes</h2>

<p><strong>Return:</strong> </p>

<pre><code>A Tree of declarations
</code></pre>
<a name="line_389" /><a name="line_391" /><div class="code"><pre><code class="perl">sub get_declarations {
	our $declarations_node;
	return $declarations_node;
}</code></pre></div><a name="line_396" /><h2>Get the PPI Parser document</h2>

<p><strong>Return:</strong> </p>

<blockquote>
<p>The PPI Document parsed from the input. </p>
</blockquote>
<a name="line_401" /><a name="line_403" /><div class="code"><pre><code class="perl">sub get_ppi_document {
	our $ppidoc;
	return $ppidoc;
}</code></pre></div><a name="line_408" /><h2>Get the type and title of a PPI element</h2>

<p><strong>Parameters:</strong> </p>

<blockquote>
<p>$cur : the element </p>
</blockquote>

<p><strong>Return:</strong> </p>

<blockquote>
<p>[ $title , $type ] </p>
</blockquote>
<a name="line_416" /><a name="line_418" /><div class="code"><pre><code class="perl">sub get_title_and_type {
	my $cur = shift;

	if ( Tools::PerlParser::Declaration::is_declaration( $cur, 1 ) ) {
		my $decl = Tools::PerlParser::Declaration-&gt;new($cur);
		return [ $decl-&gt;{title}, $decl-&gt;{type} ];
	} else {
		return [ $cur, &quot;&quot; ];
	}
}</code></pre></div><a name="line_429" /><h2>Get the documentation directly preceding a PPI Element</h2>

<p><strong>Parameters:</strong> </p>

<blockquote>
<p>$el : the element </p>
</blockquote>

<p><strong>Return:</strong> </p>

<blockquote>
<p>The first pod block in front of this statement, or all comments 
   up to the first element that is not whitespace. If no pod or comments 
   are found up to the first non-whitespace element, we return undef </p>
</blockquote>
<a name="line_439" /><a name="line_441" /><div class="code"><pre><code class="perl">sub get_documentation {
	my $el = shift;

	my $tok = $el;
	my @doc = ();
	do {
		if ( UNIVERSAL::isa( $tok, &quot;PPI::Element&quot; ) ) {
			$tok = $tok-&gt;previous_token();

			if ( UNIVERSAL::isa( $tok, &quot;PPI::Token::Whitespace&quot; ) ) {

				# skip whitespace.
			} elsif ( UNIVERSAL::isa( $tok, &quot;PPI::Token::Comment&quot; )
				|| UNIVERSAL::isa( $tok, &quot;PPI::Token::Pod&quot; ) )
			{
				unshift( @doc, $tok-&gt;content() );
				if ( UNIVERSAL::isa( $tok, &quot;PPI::Token::Pod&quot; ) ) {
					$tok = undef;
				}
			} else {
				$tok = undef;
			}
		} else {
			$tok = undef;
		}
	} while ( defined($tok) );
	return join( &quot;\n&quot;, @doc );
}</code></pre></div><a name="line_470" /><div class="code"><pre><code class="perl">sub dump {
	return Dumper(shift);
}

1;</code></pre></div></div>
<div id="footer" class="ui-widget-content ui-widget-header ui-corner-all">Generated using <a href="https://github.com/pkrusche/documenter">Perl Documenter</a> &copy; 2012 Peter Krusche</div>
</body>
</html>
